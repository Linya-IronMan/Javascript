<!DOCTYPE html>
<html lang="zh-CN">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>requestIdleCallback 完整演示</title>
		<style>
			body {
				font-family: Arial, sans-serif;
				max-width: 1000px;
				margin: 0 auto;
				padding: 20px;
				background: #f5f5f5;
			}
			.container {
				display: grid;
				grid-template-columns: 1fr 1fr;
				gap: 20px;
				margin-top: 20px;
			}
			.panel {
				background: white;
				padding: 20px;
				border-radius: 8px;
				box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
			}
			.task-item {
				padding: 8px;
				margin: 5px 0;
				background: #f8f9fa;
				border-left: 4px solid #007bff;
			}
			.completed {
				border-left-color: #28a745;
				background: #d4edda;
			}
			.progress-bar {
				width: 100%;
				height: 20px;
				background: #e9ecef;
				border-radius: 10px;
				overflow: hidden;
			}
			.progress-fill {
				height: 100%;
				background: linear-gradient(90deg, #007bff, #0056b3);
				transition: width 0.3s ease;
			}
			.stats {
				display: grid;
				grid-template-columns: 1fr 1fr;
				gap: 10px;
				margin: 15px 0;
			}
			.stat-item {
				padding: 10px;
				background: #f8f9fa;
				border-radius: 4px;
				text-align: center;
			}
			button {
				padding: 10px 15px;
				margin: 5px;
				border: none;
				border-radius: 4px;
				cursor: pointer;
				background: #007bff;
				color: white;
			}
			button:hover {
				background: #0056b3;
			}
			.warning {
				background: #fff3cd;
				border: 1px solid #ffeaa7;
				padding: 10px;
				border-radius: 4px;
				margin: 10px 0;
			}
		</style>
	</head>
	<body>
		<h1>requestIdleCallback 完整演示</h1>

		<div class="warning">
			<strong>注意：</strong> requestIdleCallback
			可能在某些浏览器中不被完全支持。 在生产环境中应考虑使用 polyfill
			或类似的调度策略。
		</div>

		<div class="container">
			<div class="panel">
				<h2>任务执行控制</h2>
				<div>
					<button onclick="startNormalTasks()">
						执行同步任务（阻塞）
					</button>
					<button onclick="startIdleTasks()">
						使用 requestIdleCallback
					</button>
					<button onclick="clearAll()">清除所有</button>
				</div>

				<div class="stats">
					<div class="stat-item">
						<div>帧率: <span id="fps">60</span> FPS</div>
					</div>
					<div class="stat-item">
						<div>任务队列: <span id="taskCount">0</span> 个</div>
					</div>
				</div>

				<div class="progress-bar">
					<div
						id="progress"
						class="progress-fill"
						style="width: 0%"
					></div>
				</div>
				<div>进度: <span id="progressText">0%</span></div>

				<h3>空闲时间统计</h3>
				<div id="idleStats">等待任务开始...</div>
			</div>

			<div class="panel">
				<h2>交互测试区域</h2>
				<p>在执行任务时尝试与这些元素交互：</p>

				<div>
					<button id="testButton">
						测试按钮（点击计数: <span>0</span>）
					</button>
					<input
						type="text"
						id="testInput"
						placeholder="尝试输入文字..."
					/>
					<div
						id="mouseArea"
						style="
							height: 100px;
							background: #e9ecef;
							margin: 10px 0;
							display: flex;
							align-items: center;
							justify-content: center;
						"
					>
						鼠标移动测试区域（移动计数: <span>0</span>）
					</div>
				</div>

				<h3>任务执行日志</h3>
				<div
					id="taskLog"
					style="
						height: 200px;
						overflow-y: auto;
						background: #f8f9fa;
						padding: 10px;
						border-radius: 4px;
					"
				></div>
			</div>
		</div>

		<script>
			class IdleTaskScheduler {
				constructor() {
					this.tasks = [];
					this.isRunning = false;
					this.taskId = 0;
					this.completedTasks = 0;
					this.totalTasks = 100; // 模拟100个任务
					this.idleCallbackId = null;

					// 性能监控
					this.frameCount = 0;
					this.lastTime = performance.now();
					this.fps = 60;

					this.setupEventListeners();
					this.startFPSCounter();
				}

				// 添加模拟任务
				addTask(duration = 10) {
					return () => {
						const start = performance.now();
						// 模拟工作 - 执行一些计算
						let result = 0;
						while (performance.now() - start < duration) {
							result += Math.random();
						}
						return result;
					};
				}

				// 初始化任务队列
				initializeTasks() {
					this.tasks = [];
					this.completedTasks = 0;
					this.updateProgress();

					for (let i = 0; i < this.totalTasks; i++) {
						// 创建不同耗时的任务
						const duration = Math.random() * 20 + 5; // 5-25ms
						this.tasks.push({
							id: i,
							execute: this.addTask(duration),
							duration: duration,
						});
					}

					document.getElementById("taskCount").textContent =
						this.tasks.length;
				}

				// 使用 requestIdleCallback 执行任务
				startIdleTasks() {
					this.initializeTasks();
					this.log("开始使用 requestIdleCallback 执行任务");
					this.isRunning = true;

					const processTask = (deadline) => {
						const stats = document.getElementById("idleStats");

						// 在空闲时间内执行尽可能多的任务
						while (
							deadline.timeRemaining() > 0 &&
							this.tasks.length > 0
						) {
							const task = this.tasks.shift();
							task.execute();
							this.completedTasks++;
							this.updateProgress();

							this.log(
								`任务 ${task.id} 完成 (剩余时间: ${deadline
									.timeRemaining()
									.toFixed(2)}ms)`
							);
						}

						// 更新统计信息
						stats.innerHTML = `
                        <div>剩余空闲时间: <strong>${deadline
							.timeRemaining()
							.toFixed(2)}ms</strong></div>
                        <div>是否超时: ${
							deadline.didTimeout ? "是" : "否"
						}</div>
                        <div>已完成: ${this.completedTasks}/${
							this.totalTasks
						}</div>
                    `;

						if (this.tasks.length > 0) {
							// 还有任务，继续请求空闲回调
							this.idleCallbackId =
								requestIdleCallback(processTask);
						} else {
							this.log("所有任务完成！");
							this.isRunning = false;
						}

						document.getElementById("taskCount").textContent =
							this.tasks.length;
					};

					// 启动处理
					this.idleCallbackId = requestIdleCallback(processTask);
				}

				// 同步执行任务（模拟阻塞）
				startNormalTasks() {
					this.initializeTasks();
					this.log("开始同步执行任务（可能阻塞页面）");

					// 禁用交互测试
					this.disableInteractions(true);

					let completed = 0;
					const total = this.tasks.length;

					// 同步执行所有任务
					this.tasks.forEach((task, index) => {
						task.execute();
						completed++;

						// 更新进度（实际上UI不会实时更新，因为主线程被阻塞）
						this.completedTasks = completed;
						this.updateProgress();
					});

					this.tasks = [];
					this.log("同步任务完成！");
					this.disableInteractions(false);
				}

				// 更新进度显示
				updateProgress() {
					const progress =
						(this.completedTasks / this.totalTasks) * 100;
					document.getElementById("progress").style.width =
						progress + "%";
					document.getElementById("progressText").textContent =
						progress.toFixed(1) + "%";
				}

				// 添加日志
				log(message) {
					const logElement = document.getElementById("taskLog");
					const timestamp = new Date().toLocaleTimeString();
					const logEntry = document.createElement("div");
					logEntry.textContent = `[${timestamp}] ${message}`;
					logElement.appendChild(logEntry);
					logElement.scrollTop = logElement.scrollHeight;
				}

				// 设置事件监听器
				setupEventListeners() {
					let clickCount = 0;
					let mouseMoveCount = 0;

					document
						.getElementById("testButton")
						.addEventListener("click", () => {
							clickCount++;
							document.querySelector(
								"#testButton span"
							).textContent = clickCount;
						});

					document
						.getElementById("testInput")
						.addEventListener("input", (e) => {
							// 输入测试
						});

					document
						.getElementById("mouseArea")
						.addEventListener("mousemove", () => {
							mouseMoveCount++;
							document.querySelector(
								"#mouseArea span"
							).textContent = mouseMoveCount;
						});
				}

				// 禁用/启用交互
				disableInteractions(disabled) {
					const button = document.getElementById("testButton");
					const input = document.getElementById("testInput");

					button.disabled = disabled;
					input.disabled = disabled;
					input.placeholder = disabled
						? "页面阻塞中..."
						: "尝试输入文字...";
				}

				// FPS 计数器
				startFPSCounter() {
					const countFPS = () => {
						this.frameCount++;
						const currentTime = performance.now();

						if (currentTime >= this.lastTime + 1000) {
							this.fps = Math.round(
								(this.frameCount * 1000) /
									(currentTime - this.lastTime)
							);
							this.lastTime = currentTime;
							this.frameCount = 0;

							document.getElementById("fps").textContent =
								this.fps;

							// FPS 颜色提示
							const fpsElement = document.getElementById("fps");
							if (this.fps < 30) {
								fpsElement.style.color = "red";
								fpsElement.style.fontWeight = "bold";
							} else if (this.fps < 50) {
								fpsElement.style.color = "orange";
							} else {
								fpsElement.style.color = "green";
							}
						}

						requestAnimationFrame(countFPS);
					};

					countFPS();
				}

				// 清除所有
				clearAll() {
					if (this.idleCallbackId) {
						cancelIdleCallback(this.idleCallbackId);
					}

					this.tasks = [];
					this.isRunning = false;
					this.completedTasks = 0;
					this.updateProgress();

					document.getElementById("taskLog").innerHTML = "";
					document.getElementById("idleStats").innerHTML =
						"等待任务开始...";
					document.getElementById("taskCount").textContent = "0";
				}
			}

			// 初始化调度器
			const scheduler = new IdleTaskScheduler();

			// 全局函数供按钮调用
			function startNormalTasks() {
				scheduler.startNormalTasks();
			}
			function startIdleTasks() {
				scheduler.startIdleTasks();
			}
			function clearAll() {
				scheduler.clearAll();
			}

			// 兼容性检查
			if (!("requestIdleCallback" in window)) {
				document.querySelector(".warning").innerHTML +=
					'<br><strong style="color: red;">当前浏览器不支持 requestIdleCallback！</strong>';
			}
		</script>
	</body>
</html>
